# v0.3.1
# { "Depends": "py-genlayer:latest" }

from genlayer import *
import time
import typing
import json


class DeferredValueSwap(gl.Contract):
    """
    Deferred-value deal/token contract on GenLayer.

    - sender ↔ recipient
    - lifecycle:
        INACTIVE → ACTIVE → (FINAL_NFT | FINAL_STABLE | CANCELLED | DISPUTED)
    - native GEN deposit locked at creation
    - final outcome: payout to recipient (STABLE) or logical “NFT”-style completion
    - safety: blacklist, value limits, action throttling
    - optional dispute: claim/challenge + AI arbitration
    - simple reputation (XP / wins)
    """

    # =========================
    # 1. STATE CONSTANTS
    # =========================

    def _STATE_INACTIVE(self) -> u256:
        return u256(0)

    def _STATE_ACTIVE(self) -> u256:
        return u256(1)

    def _STATE_FINAL_NFT(self) -> u256:
        return u256(2)

    def _STATE_FINAL_STABLE(self) -> u256:
        return u256(3)

    def _STATE_CANCELLED(self) -> u256:
        return u256(4)

    def _STATE_DISPUTED(self) -> u256:
        return u256(5)

    # =========================
    # 2. DEAL STORAGE
    # =========================

    next_deal_id: u256

    deal_sender: TreeMap[u256, Address]
    deal_recipient: TreeMap[u256, Address]
    deal_state: TreeMap[u256, u256]

    deal_initial_value: TreeMap[u256, u256]     # nominal value in GEN
    deal_current_value: TreeMap[u256, u256]     # after applying multiplier
    deal_deposit: TreeMap[u256, u256]           # actual GEN locked as deposit

    deal_created_at: TreeMap[u256, u256]
    deal_activated_at: TreeMap[u256, u256]
    deal_finalized_at: TreeMap[u256, u256]

    deal_activation_deadline: TreeMap[u256, u256]
    deal_finalization_deadline: TreeMap[u256, u256]

    deal_offchain_ref: TreeMap[u256, str]
    deal_nft_metadata: TreeMap[u256, str]

    # =========================
    # 3. DISPUTES
    # =========================

    deal_dispute_open: TreeMap[u256, u256]       # 0/1 flag
    deal_claim_by: TreeMap[u256, Address]
    deal_claim_reason: TreeMap[u256, str]
    deal_claim_opened_at: TreeMap[u256, u256]
    deal_claim_deadline: TreeMap[u256, u256]

    deal_challenge_by: TreeMap[u256, Address]
    deal_challenge_reason: TreeMap[u256, str]

    deal_resolution_mode: TreeMap[u256, u256]    # 0=none, 1=owner_manual, 2=ai_judge
    deal_resolution_note: TreeMap[u256, str]

    dispute_period_sec: u256                     # dispute window duration

    # =========================
    # 4. ECONOMICS / FEES
    # =========================

    base_activation_fee: u256                    # fee charged when creating a deal
    global_value_multiplier_bps: u256            # 10000 = 1.0x
    transform_fee_bps: u256                      # fee on FINAL_STABLE, in bps

    protocol_fees_collected: u256                # total GEN collected by protocol

    # =========================
    # 5. SECURITY
    # =========================

    blacklisted: TreeMap[Address, u256]          # 1 if blocked

    max_deal_value: u256                         # cap on initial_value/deposit, 0 = no cap
    min_delay_sec: u256                          # minimal delay between actions per address
    last_action_at: TreeMap[Address, u256]

    default_activation_period_sec: u256          # default time allowed to activate
    default_finalization_period_sec: u256        # default time allowed to finalize

    # =========================
    # 6. REPUTATION
    # =========================

    xp: TreeMap[Address, u256]
    wins: TreeMap[Address, u256]

    # =========================
    # 7. ADMIN
    # =========================

    owner: Address

    # =========================
    # HELPER FUNCTIONS
    # =========================

    def _now(self) -> u256:
        return u256(int(time.time()))

    def _only_owner(self) -> None:
        if gl.message.sender_address != self.owner:
            raise UserError("Only owner")

    def _not_blacklisted(self, addr: Address) -> None:
        if self.blacklisted.get(addr, u256(0)) == u256(1):
            raise UserError("Blacklisted")

    def _respect_delay(self, addr: Address) -> None:
        if self.min_delay_sec == u256(0):
            return
        last = self.last_action_at.get(addr, u256(0))
        now = self._now()
        if last != u256(0) and now < last + self.min_delay_sec:
            raise UserError("Action too frequent")
        self.last_action_at[addr] = now

    def _only_sender(self, deal_id: u256) -> None:
        sender = self.deal_sender.get(deal_id)
        if sender is None:
            raise UserError("Unknown deal")
        if sender != gl.message.sender_address:
            raise UserError("Only sender")

    def _only_recipient(self, deal_id: u256) -> None:
        recipient = self.deal_recipient.get(deal_id)
        if recipient is None:
            raise UserError("Unknown deal")
        if recipient != gl.message.sender_address:
            raise UserError("Only recipient")

    def _only_participant(self, deal_id: u256) -> None:
        me = gl.message.sender_address
        sender = self.deal_sender.get(deal_id)
        recipient = self.deal_recipient.get(deal_id)

        if sender is None:
            raise UserError("Unknown deal")

        if me != sender and me != recipient:
            raise UserError("Only sender or recipient")

    def _calc_value(self, initial: u256) -> u256:
        if self.global_value_multiplier_bps == u256(0):
            return initial
        return (initial * self.global_value_multiplier_bps) // u256(10_000)

    def _send_native(self, to: Address, amount: u256) -> None:
        if amount == u256(0):
            return
        if self.balance < amount:
            raise UserError("Contract balance insufficient")
        proxy = gl.get_contract_at(to)
        proxy.emit_transfer(value=amount)

    def _parse_json(self, raw: str) -> typing.Any:
        cleaned = raw.replace("```json", "").replace("```", "").strip()
        return json.loads(cleaned)

    # =========================
    # 8. CONSTRUCTOR
    # =========================

    def __init__(self):
        self.next_deal_id = u256(1)
        self.owner = gl.message.sender_address

        self.base_activation_fee = u256(0)
        self.global_value_multiplier_bps = u256(10_000)  # 1.0x
        self.transform_fee_bps = u256(100)               # 1%

        self.protocol_fees_collected = u256(0)

        self.max_deal_value = u256(0)
        self.min_delay_sec = u256(0)

        self.default_activation_period_sec = u256(0)
        self.default_finalization_period_sec = u256(0)

        self.dispute_period_sec = u256(0)

    # =========================
    # 9. DEAL CREATION & ACTIVATION
    # =========================

    @gl.public.write.payable
    def create_deal(
        self,
        recipient_hex: str,
        value: int,
        offchain_ref: str,
    ) -> int:
        sender = gl.message.sender_address
        self._not_blacklisted(sender)
        self._respect_delay(sender)

        if value <= 0:
            raise UserError("Value must be > 0")

        v = u256(value)
        if self.max_deal_value != u256(0) and v > self.max_deal_value:
            raise UserError("Value exceeds max_deal_value")

        recipient = Address(recipient_hex)
        self._not_blacklisted(recipient)

        sent = gl.message.value
        fee = self.base_activation_fee
        expected = v + fee
        if sent != expected:
            raise UserError("Sent value must equal value + base_activation_fee")

        deposit = v
        if fee > u256(0):
            self.protocol_fees_collected += fee

        deal_id = self.next_deal_id
        self.next_deal_id = deal_id + u256(1)

        now = self._now()

        self.deal_sender[deal_id] = sender
        self.deal_recipient[deal_id] = recipient
        self.deal_state[deal_id] = self._STATE_INACTIVE()

        self.deal_initial_value[deal_id] = v
        self.deal_current_value[deal_id] = self._calc_value(v)
        self.deal_deposit[deal_id] = deposit

        self.deal_created_at[deal_id] = now
        self.deal_offchain_ref[deal_id] = offchain_ref

        if self.default_activation_period_sec > u256(0):
            self.deal_activation_deadline[deal_id] = now + self.default_activation_period_sec
        else:
            self.deal_activation_deadline[deal_id] = u256(0)

        self.deal_finalization_deadline[deal_id] = u256(0)

        self.xp[sender] = self.xp.get(sender, u256(0)) + u256(1)

        return int(deal_id)

    @gl.public.write
    def activate_deal(self, deal_id_int: int) -> None:
        deal_id = u256(deal_id_int)
        self._only_participant(deal_id)
        self._not_blacklisted(gl.message.sender_address)
        self._respect_delay(gl.message.sender_address)

        state = self.deal_state.get(deal_id, u256(99))
        if state != self._STATE_INACTIVE():
            raise UserError("Deal not inactive")

        deadline = self.deal_activation_deadline.get(deal_id, u256(0))
        if deadline != u256(0) and self._now() > deadline:
            raise UserError("Activation deadline passed")

        self.deal_state[deal_id] = self._STATE_ACTIVE()
        now = self._now()
        self.deal_activated_at[deal_id] = now

        if self.default_finalization_period_sec > u256(0):
            self.deal_finalization_deadline[deal_id] = now + self.default_finalization_period_sec

        s = self.deal_sender[deal_id]
        r = self.deal_recipient[deal_id]
        self.xp[s] = self.xp.get(s, u256(0)) + u256(1)
        self.xp[r] = self.xp.get(r, u256(0)) + u256(1)

    # =========================
    # 10. CANCELLATION / EXPIRY
    # =========================

    @gl.public.write
    def cancel_inactive(self, deal_id_int: int) -> None:
        deal_id = u256(deal_id_int)
        self._only_sender(deal_id)
        self._not_blacklisted(gl.message.sender_address)
        self._respect_delay(gl.message.sender_address)

        state = self.deal_state.get(deal_id, u256(99))
        if state != self._STATE_INACTIVE():
            raise UserError("Deal not inactive")

        deposit = self.deal_deposit.get(deal_id, u256(0))
        if deposit > u256(0):
            self.deal_deposit[deal_id] = u256(0)
            self._send_native(self.deal_sender[deal_id], deposit)

        self.deal_state[deal_id] = self._STATE_CANCELLED()
        self.deal_finalized_at[deal_id] = self._now()

    @gl.public.write
    def expire_deal(self, deal_id_int: int) -> None:
        deal_id = u256(deal_id_int)
        self._only_participant(deal_id)
        self._not_blacklisted(gl.message.sender_address)
        self._respect_delay(gl.message.sender_address)

        state = self.deal_state.get(deal_id, u256(99))
        now = self._now()

        if state == self._STATE_INACTIVE():
            deadline = self.deal_activation_deadline.get(deal_id, u256(0))
            if deadline == u256(0) or now <= deadline:
                raise UserError("Activation deadline not passed")
        elif state == self._STATE_ACTIVE():
            deadline = self.deal_finalization_deadline.get(deal_id, u256(0))
            if deadline == u256(0) or now <= deadline:
                raise UserError("Finalization deadline not passed")
        else:
            raise UserError("Not expirable state")

        deposit = self.deal_deposit.get(deal_id, u256(0))
        if deposit > u256(0):
            self.deal_deposit[deal_id] = u256(0)
            self._send_native(self.deal_sender[deal_id], deposit)

        self.deal_state[deal_id] = self._STATE_CANCELLED()
        self.deal_finalized_at[deal_id] = now

    # =========================
    # 11. FINALIZATION: NFT / STABLE
    # =========================

    @gl.public.write
    def finalize_to_nft(self, deal_id_int: int, metadata: str) -> None:
        deal_id = u256(deal_id_int)
        self._only_recipient(deal_id)
        self._not_blacklisted(gl.message.sender_address)
        self._respect_delay(gl.message.sender_address)

        state = self.deal_state.get(deal_id, u256(99))
        if state != self._STATE_ACTIVE():
            raise UserError("Deal not active")

        deadline = self.deal_finalization_deadline.get(deal_id, u256(0))
        if deadline != u256(0) and self._now() > deadline:
            raise UserError("Finalization deadline passed")

        self.deal_state[deal_id] = self._STATE_FINAL_NFT()
        self.deal_nft_metadata[deal_id] = metadata
        self.deal_finalized_at[deal_id] = self._now()

        r = self.deal_recipient[deal_id]
        self.xp[r] = self.xp.get(r, u256(0)) + u256(5)
        self.wins[r] = self.wins.get(r, u256(0)) + u256(1)

    @gl.public.write
    def finalize_to_stable(self, deal_id_int: int) -> int:
        deal_id = u256(deal_id_int)
        self._only_recipient(deal_id)
        self._not_blacklisted(gl.message.sender_address)
        self._respect_delay(gl.message.sender_address)

        state = self.deal_state.get(deal_id, u256(99))
        if state != self._STATE_ACTIVE():
            raise UserError("Deal not active")

        deadline = self.deal_finalization_deadline.get(deal_id, u256(0))
        if deadline != u256(0) and self._now() > deadline:
            raise UserError("Finalization deadline passed")

        deposit = self.deal_deposit.get(deal_id, u256(0))
        if deposit == u256(0):
            raise UserError("No deposit")

        fee = (deposit * self.transform_fee_bps) // u256(10_000)
        if fee > deposit:
            fee = deposit

        net = deposit - fee
        if net == u256(0):
            raise UserError("Net amount is zero")

        recipient = self.deal_recipient[deal_id]

        self.deal_state[deal_id] = self._STATE_FINAL_STABLE()
        self.deal_finalized_at[deal_id] = self._now()
        self.deal_current_value[deal_id] = net
        self.deal_deposit[deal_id] = u256(0)

        self._send_native(recipient, net)
        self.protocol_fees_collected += fee

        self.xp[recipient] = self.xp.get(recipient, u256(0)) + u256(5)
        self.wins[recipient] = self.wins.get(recipient, u256(0)) + u256(1)

        return int(net)

    # =========================
    # 12. DISPUTES
    # =========================

    @gl.public.write
    def open_dispute(self, deal_id_int: int, reason: str) -> None:
        deal_id = u256(deal_id_int)
        self._only_participant(deal_id)
        self._not_blacklisted(gl.message.sender_address)
        self._respect_delay(gl.message.sender_address)

        if self.dispute_period_sec == u256(0):
            raise UserError("Disputes disabled")

        state = self.deal_state.get(deal_id, u256(99))
        if state not in (self._STATE_INACTIVE(), self._STATE_ACTIVE()):
            raise UserError("Dispute only for inactive/active deals")

        if self.deal_dispute_open.get(deal_id, u256(0)) == u256(1):
            raise UserError("Dispute already open")

        if reason.strip() == "":
            raise UserError("Empty reason")

        now = self._now()
        self.deal_dispute_open[deal_id] = u256(1)
        self.deal_state[deal_id] = self._STATE_DISPUTED()
        self.deal_claim_by[deal_id] = gl.message.sender_address
        self.deal_claim_reason[deal_id] = reason
        self.deal_claim_opened_at[deal_id] = now
        self.deal_claim_deadline[deal_id] = now + self.dispute_period_sec

    @gl.public.write
    def challenge_dispute(self, deal_id_int: int, reason: str) -> None:
        deal_id = u256(deal_id_int)
        self._only_participant(deal_id)
        self._not_blacklisted(gl.message.sender_address)
        self._respect_delay(gl.message.sender_address)

        if self.deal_dispute_open.get(deal_id, u256(0)) != u256(1):
            raise UserError("No open dispute")

        if reason.strip() == "":
            raise UserError("Empty reason")

        claim_by = self.deal_claim_by.get(deal_id)
        if claim_by is None:
            raise UserError("Internal error: no claim_by")
        if claim_by == gl.message.sender_address:
            raise UserError("Claimant cannot challenge themselves")

        if self.deal_challenge_by.get(deal_id) is not None:
            raise UserError("Challenge already set")

        self.deal_challenge_by[deal_id] = gl.message.sender_address
        self.deal_challenge_reason[deal_id] = reason

    def _ai_resolve_dispute(self, deal_id: u256) -> str:
        sender = self.deal_sender[deal_id]
        recipient = self.deal_recipient[deal_id]
        offref = self.deal_offchain_ref.get(deal_id, "")
        claim_by = self.deal_claim_by.get(deal_id)
        claim_reason = self.deal_claim_reason.get(deal_id, "")
        challenge_by = self.deal_challenge_by.get(deal_id)
        challenge_reason = self.deal_challenge_reason.get(deal_id, "")
        deposit = self.deal_deposit.get(deal_id, u256(0))

        info = {
            "deal_id": int(deal_id),
            "sender": sender.as_hex,
            "recipient": None if recipient is None else recipient.as_hex,
            "offchain_ref": offref,
            "claim_by": None if claim_by is None else claim_by.as_hex,
            "claim_reason": claim_reason,
            "challenge_by": None if challenge_by is None else challenge_by.as_hex,
            "challenge_reason": challenge_reason,
            "deposit": int(deposit),
        }

        task = (
            "You are an AI arbitrator for a GenLayer deferred-value deal.\n"
            "Choose ONE of two outcomes:\n"
            "- \"sender_refund\": fully refund deposit to the sender.\n"
            "- \"release_to_recipient\": release deposit to the recipient.\n\n"
            "Return STRICT JSON:\n"
            "{\"decision\": \"sender_refund\"|\"release_to_recipient\", "
            "\"explanation\": \"...\"}\n"
            "No markdown, no ``` fences."
        )

        def leader() -> str:
            res = _prompt(task + "\n\n" + json.dumps(info))
            return str(res)

        def validator(result) -> bool:
            try:
                raw = result.value  # type: ignore[attr-defined]
            except Exception:
                return False
            try:
                data = self._parse_json(str(raw))
            except Exception:
                return False

            decision = data.get("decision")
            expl = data.get("explanation")
            if not isinstance(decision, str) or not isinstance(expl, str):
                return False
            if decision not in ["sender_refund", "release_to_recipient"]:
                return False
            if len(expl) == 0 or len(expl) > 500:
                return False
            return True

        out = gl._nondet(leader, validator)
        data = self._parse_json(str(out))
        decision = str(data["decision"])
        explanation = str(data.get("explanation", ""))

        self.deal_resolution_note[deal_id] = explanation
        return decision

    @gl.public.write
    def resolve_dispute_ai(self, deal_id_int: int) -> None:
        self._only_owner()
        deal_id = u256(deal_id_int)

        if self.deal_dispute_open.get(deal_id, u256(0)) != u256(1):
            raise UserError("No open dispute")

        deadline = self.deal_claim_deadline.get(deal_id, u256(0))
        if deadline != u256(0) and self._now() <= deadline:
            raise UserError("Dispute window not closed")

        decision = self._ai_resolve_dispute(deal_id)
        deposit = self.deal_deposit.get(deal_id, u256(0))

        sender = self.deal_sender[deal_id]
        recipient = self.deal_recipient[deal_id]

        if decision == "sender_refund":
            if deposit > u256(0):
                self.deal_deposit[deal_id] = u256(0)
                self._send_native(sender, deposit)
            self.deal_state[deal_id] = self._STATE_CANCELLED()
            self.wins[sender] = self.wins.get(sender, u256(0)) + u256(1)
            self.xp[sender] = self.xp.get(sender, u256(0)) + u256(5)
        else:
            if deposit > u256(0):
                self.deal_deposit[deal_id] = u256(0)
                self._send_native(recipient, deposit)
            self.deal_state[deal_id] = self._STATE_FINAL_STABLE()
            self.deal_current_value[deal_id] = deposit
            self.wins[recipient] = self.wins.get(recipient, u256(0)) + u256(1)
            self.xp[recipient] = self.xp.get(recipient, u256(0)) + u256(5)

        self.deal_finalized_at[deal_id] = self._now()
        self.deal_dispute_open[deal_id] = u256(0)
        self.deal_resolution_mode[deal_id] = u256(2)

    @gl.public.write
    def resolve_dispute_owner(self, deal_id_int: int, send_to_recipient: bool, note: str) -> None:
        self._only_owner()
        deal_id = u256(deal_id_int)

        if self.deal_dispute_open.get(deal_id, u256(0)) != u256(1):
            raise UserError("No open dispute")

        deposit = self.deal_deposit.get(deal_id, u256(0))
        sender = self.deal_sender[deal_id]
        recipient = self.deal_recipient[deal_id]

        if send_to_recipient:
            if deposit > u256(0):
                self.deal_deposit[deal_id] = u256(0)
                self._send_native(recipient, deposit)
            self.deal_state[deal_id] = self._STATE_FINAL_STABLE()
            self.deal_current_value[deal_id] = deposit
            self.wins[recipient] = self.wins.get(recipient, u256(0)) + u256(1)
            self.xp[recipient] = self.xp.get(recipient, u256(0)) + u256(5)
        else:
            if deposit > u256(0):
                self.deal_deposit[deal_id] = u256(0)
                self._send_native(sender, deposit)
            self.deal_state[deal_id] = self._STATE_CANCELLED()
            self.wins[sender] = self.wins.get(sender, u256(0)) + u256(1)
            self.xp[sender] = self.xp.get(sender, u256(0)) + u256(5)

        self.deal_finalized_at[deal_id] = self._now()
        self.deal_dispute_open[deal_id] = u256(0)
        self.deal_resolution_mode[deal_id] = u256(1)
        self.deal_resolution_note[deal_id] = note

    # =========================
    # 13. ADMIN / SETTINGS
    # =========================

    @gl.public.write
    def set_blacklist(self, addr_hex: str, blocked: bool) -> None:
        self._only_owner()
        addr = Address(addr_hex)
        self.blacklisted[addr] = u256(1 if blocked else 0)

    @gl.public.write
    def set_security_params(self, max_value: int, min_delay_seconds: int) -> None:
        self._only_owner()
        if max_value < 0 or min_delay_seconds < 0:
            raise UserError("Must be >= 0")
        self.max_deal_value = u256(max_value)
        self.min_delay_sec = u256(min_delay_seconds)

    @gl.public.write
    def set_timeouts(self, activation_sec: int, finalization_sec: int, dispute_sec: int) -> None:
        self._only_owner()
        if activation_sec < 0 or finalization_sec < 0 or dispute_sec < 0:
            raise UserError("Must be >= 0")
        self.default_activation_period_sec = u256(activation_sec)
        self.default_finalization_period_sec = u256(finalization_sec)
        self.dispute_period_sec = u256(dispute_sec)

    @gl.public.write
    def set_economics(self, activation_fee: int, multiplier_bps: int, transform_fee_bps: int) -> None:
        self._only_owner()
        if activation_fee < 0 or multiplier_bps <= 0 or transform_fee_bps < 0:
            raise UserError("Invalid params")
        if transform_fee_bps > 2000:
            raise UserError("Fee too high (>20%)")

        self.base_activation_fee = u256(activation_fee)
        self.global_value_multiplier_bps = u256(multiplier_bps)
        self.transform_fee_bps = u256(transform_fee_bps)

    @gl.public.write
    def withdraw_protocol_fees(self, to_hex: str, amount: int) -> None:
        self._only_owner()
        if amount <= 0:
            raise UserError("amount must be > 0")
        a = u256(amount)
        if a > self.protocol_fees_collected:
            raise UserError("Amount exceeds protocol_fees_collected")

        to = Address(to_hex)
        self.protocol_fees_collected -= a
        self._send_native(to, a)

    # =========================
    # 14. VIEW FUNCTIONS
    # =========================

    @gl.public.view
    def get_deal(self, deal_id_int: int) -> dict[str, typing.Any]:
        deal_id = u256(deal_id_int)
        s = self.deal_sender.get(deal_id)
        r = self.deal_recipient.get(deal_id)
        if s is None:
            raise UserError("Unknown deal")
        return {
            "id": deal_id_int,
            "sender": s.as_hex,
            "recipient": r.as_hex if r is not None else None,
            "state": int(self.deal_state.get(deal_id, u256(255))),
            "initial_value": int(self.deal_initial_value.get(deal_id, u256(0))),
            "current_value": int(self.deal_current_value.get(deal_id, u256(0))),
            "deposit": int(self.deal_deposit.get(deal_id, u256(0))),
            "created_at": int(self.deal_created_at.get(deal_id, u256(0))),
            "activated_at": int(self.deal_activated_at.get(deal_id, u256(0))),
            "finalized_at": int(self.deal_finalized_at.get(deal_id, u256(0))),
            "activation_deadline": int(self.deal_activation_deadline.get(deal_id, u256(0))),
            "finalization_deadline": int(self.deal_finalization_deadline.get(deal_id, u256(0))),
            "offchain_ref": self.deal_offchain_ref.get(deal_id, ""),
            "nft_metadata": self.deal_nft_metadata.get(deal_id, ""),
            "dispute_open": int(self.deal_dispute_open.get(deal_id, u256(0))),
            "claim_by": None if self.deal_claim_by.get(deal_id) is None else self.deal_claim_by[deal_id].as_hex,
            "claim_reason": self.deal_claim_reason.get(deal_id, ""),
            "claim_deadline": int(self.deal_claim_deadline.get(deal_id, u256(0))),
            "challenge_by": None if self.deal_challenge_by.get(deal_id) is None else self.deal_challenge_by[deal_id].as_hex,
            "challenge_reason": self.deal_challenge_reason.get(deal_id, ""),
            "resolution_mode": int(self.deal_resolution_mode.get(deal_id, u256(0))),
            "resolution_note": self.deal_resolution_note.get(deal_id, ""),
        }

    @gl.public.view
    def get_my_xp(self) -> int:
        return int(self.xp.get(gl.message.sender_address, u256(0)))

    @gl.public.view
    def get_xp(self, addr_hex: str) -> int:
        addr = Address(addr_hex)
        return int(self.xp.get(addr, u256(0)))

    @gl.public.view
    def get_wins(self, addr_hex: str) -> int:
        addr = Address(addr_hex)
        return int(self.wins.get(addr, u256(0)))

    @gl.public.view
    def get_config(self) -> dict[str, typing.Any]:
        return {
            "base_activation_fee": int(self.base_activation_fee),
            "global_value_multiplier_bps": int(self.global_value_multiplier_bps),
            "transform_fee_bps": int(self.transform_fee_bps),
            "max_deal_value": int(self.max_deal_value),
            "min_delay_sec": int(self.min_delay_sec),
            "default_activation_period_sec": int(self.default_activation_period_sec),
            "default_finalization_period_sec": int(self.default_finalization_period_sec),
            "dispute_period_sec": int(self.dispute_period_sec),
            "protocol_fees_collected": int(self.protocol_fees_collected),
        }
