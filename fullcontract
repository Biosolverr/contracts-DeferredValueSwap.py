# v0.3.1
# { "Depends": "py-genlayer:latest" }

from genlayer import *
import time
import typing
import json


class DeferredValueSwap(gl.Contract):
    """
    Deferred-value token/deal contract on GenLayer:

    - sender ↔ recipient
    - lifecycle:
        INACTIVE → ACTIVE → (FINAL_NFT | FINAL_STABLE | CANCELLED | DISPUTED)
    - native GEN deposit at creation
    - final outcome: release deposit to recipient (STABLE) or logical "NFT" finalization
    - security: blacklist, limits, rate delay
    - optional dispute: claim/challenge + AI arbitration
    - simple reputation (XP / wins)
    """

    # =========================
    # 1. STATE CONSTANTS
    # =========================

    def _STATE_INACTIVE(self) -> u256:
        return u256(0)

    def _STATE_ACTIVE(self) -> u256:
        return u256(1)

    def _STATE_FINAL_NFT(self) -> u256:
        return u256(2)

    def _STATE_FINAL_STABLE(self) -> u256:
        return u256(3)

    def _STATE_CANCELLED(self) -> u256:
        return u256(4)

    def _STATE_DISPUTED(self) -> u256:
        return u256(5)

    # =========================
    # 2. DEAL STORAGE
    # =========================

    next_deal_id: u256

    deal_sender: TreeMap[u256, Address]
    deal_recipient: TreeMap[u256, Address]
    deal_state: TreeMap[u256, u256]

    deal_initial_value: TreeMap[u256, u256]     # nominal amount in GEN
    deal_current_value: TreeMap[u256, u256]     # with multiplier applied
    deal_deposit: TreeMap[u256, u256]           # how much GEN is actually locked

    deal_created_at: TreeMap[u256, u256]
    deal_activated_at: TreeMap[u256, u256]
    deal_finalized_at: TreeMap[u256, u256]

    deal_activation_deadline: TreeMap[u256, u256]
    deal_finalization_deadline: TreeMap[u256, u256]

    deal_offchain_ref: TreeMap[u256, str]
    deal_nft_metadata: TreeMap[u256, str]

    # =========================
    # 3. DISPUTES
    # =========================

    deal_dispute_open: TreeMap[u256, u256]       # 0/1
    deal_claim_by: TreeMap[u256, Address]
    deal_claim_reason: TreeMap[u256, str]
    deal_claim_opened_at: TreeMap[u256, u256]
    deal_claim_deadline: TreeMap[u256, u256]

    deal_challenge_by: TreeMap[u256, Address]
    deal_challenge_reason: TreeMap[u256, str]

    deal_resolution_mode: TreeMap[u256, u256]    # 0=none,1=owner_manual,2=ai_judge
    deal_resolution_note: TreeMap[u256, str]

    dispute_period_sec: u256                     # dispute window

    # =========================
    # 4. ECONOMICS / FEES
    # =========================

    base_activation_fee: u256                    # fee on deal creation
    global_value_multiplier_bps: u256            # 10000 = 1.0x
    transform_fee_bps: u256                      # fee on STABLE finalization, bps

    protocol_fees_collected: u256                # how much GEN the protocol collected

    # =========================
    # 5. SECURITY
    # =========================

    blacklisted: TreeMap[Address, u256]          # 1 if blocked

    max_deal_value: u256                         # cap for initial_value/deposit, 0 = no cap
    min_delay_sec: u256                          # minimum delay between actions
    last_action_at: TreeMap[Address, u256]

    default_activation_period_sec: u256          # default: how long to activate
    default_finalization_period_sec: u256        # default: how long to finalize

    # =========================
    # 6. REPUTATION
    # =========================

    xp: TreeMap[Address, u256]
    wins: TreeMap[Address, u256]

    # =========================
    # 7. ADMIN
    # =========================

    owner: Address

    # =========================
    # HELPER FUNCTIONS
    # =========================

    def _now(self) -> u256:
        return u256(int(time.time()))

    def _only_owner(self) -> None:
        if gl.message.sender_address != self.owner:
            raise UserError("Only owner")

    def _not_blacklisted(self, addr: Address) -> None:
        if self.blacklisted.get(addr, u256(0)) == u256(1):
            raise UserError("Blacklisted")

    def _respect_delay(self, addr: Address) -> None:
        if self.min_delay_sec == u256(0):
            return
        last = self.last_action_at.get(addr, u256(0))
        now = self._now()
        if last != u256(0) and now < last + self.min_delay_sec:
            raise UserError("Action too frequent")
        self.last_action_at[addr] = now

    def _only_sender(self, deal_id: u256) -> None:
        sender = self.deal_sender.get(deal_id)
        if sender is None:
            raise UserError("Unknown deal")
        if sender != gl.message.sender_address:
            raise UserError("Only sender")

    def _only_recipient(self, deal_id: u256) -> None:
        recipient = self.deal_recipient.get(deal_id)
        if recipient is None:
            raise UserError("Unknown deal")
        if recipient != gl.message.sender_address:
            raise UserError("Only recipient")

    def _only_participant(self, deal_id: u256) -> None:
        me = gl.message.sender_address
        sender = self.deal_sender.get(deal_id)
        recipient = self.deal_recipient.get(deal_id)

        if sender is None:
            raise UserError("Unknown deal")

        if me != sender and me != recipient:
            raise UserError("Only sender or recipient")

    def _calc_value(self, initial: u256) -> u256:
        if self.global_value_multiplier_bps == u256(0):
            return initial
        return (initial * self.global_value_multiplier_bps) // u256(10_000)

    def _send_native(self, to: Address, amount: u256) -> None:
        if amount == u256(0):
            return
        if self.balance < amount:
            raise UserError("Contract balance insufficient")
        proxy = gl.get_contract_at(to)
        proxy.emit_transfer(value=amount)

    def _parse_json(self, raw: str) -> typing.Any:
        cleaned = raw.replace("```json", "").replace("```", "").strip()
        return json.loads(cleaned)

    # =========================
    # 8. CONSTRUCTOR
    # =========================

    def __init__(self):
        self.next_deal_id = u256(1)
        self.owner = gl.message.sender_address

        self.base_activation_fee = u256(0)
        self.global_value_multiplier_bps = u256(10_000)  # 1.0x
        self.transform_fee_bps = u256(100)               # 1%

        self.protocol_fees_collected = u256(0)

        self.max_deal_value = u256(0)
        self.min_delay_sec = u256(0)

        self.default_activation_period_sec = u256(0)
        self.default_finalization_period_sec = u256(0)

        self.dispute_period_sec = u256(0)

    # =========================
    # 9. DEAL CREATION & ACTIVATION
    # =========================

    @gl.public.write.payable
    def create_deal(
        self,
        recipient_hex: str,
        value: int,
        offchain_ref: str,
    ) -> int:
        sender = gl.message.sender_address
        self._not_blacklisted(sender)
        self._respect_delay(sender)

        if value <= 0:
            raise UserError("Value must be > 0")

        v = u256(value)
        if self.max_deal_value != u256(0) and v > self.max_deal_value:
            raise UserError("Value exceeds max_deal_value")

        recipient = Address(recipient_hex)
        self._not_blacklisted(recipient)

        sent = gl.message.value
        fee = self.base_activation_fee
        expected = v + fee
        if sent != expected:
            raise UserError("Sent value must equal value + base_activation_fee")

        deposit = v
        if fee > u256(0):
            self.protocol_fees_collected += fee

        deal_id = self.next_deal_id
        self.next_deal_id = deal_id + u256(1)

        now = self._now()

        self.deal_sender[deal_id] = sender
        self.deal_recipient[deal_id] = recipient
        self.deal_state[deal_id] = self._STATE_INACTIVE()

        self.deal_initial_value[deal_id] = v
        self.deal_current_value[deal_id] = self._calc_value(v)
        self.deal_deposit[deal_id] = deposit

        self.deal_created_at[deal_id] = now
        self.deal_offchain_ref[deal_id] = offchain_ref

        if self.default_activation_period_sec > u256(0):
            self.deal_activation_deadline[deal_id] = now + self.default_activation_period_sec
        else:
            self.deal_activation_deadline[deal_id] = u256(0)

        self.deal_finalization_deadline[deal_id] = u256(0)

        self.xp[sender] = self.xp.get(sender, u256(0)) + u256(1)

        return int(deal_id)

    @gl.public.write
    def activate_deal(self, deal_id_int: int) -> None:
        deal_id = u256(deal_id_int)
        self._only_participant(deal_id)
        self._not_blacklisted(gl.message.sender_address)
        self._respect_delay(gl.message.sender_address)

        state = self.deal_state.get(deal_id, u256(99))
        if state != self._STATE_INACTIVE():
            raise UserError("Deal not inactive")

        deadline = self.deal_activation_deadline.get(deal_id, u256(0))
        if deadline != u256(0) and self._now() > deadline:
            raise UserError("Activation deadline passed")

        self.deal_state[deal_id] = self._STATE_ACTIVE()
        now = self._now()
        self.deal_activated_at[deal_id] = now

        if self.default_finalization_period_sec > u256(0):
            self.deal_finalization_deadline[deal_id] = now + self.default_finalization_period_sec

        s = self.deal_sender[deal_id]
        r = self.deal_recipient[deal_id]
        self.xp[s] = self.xp.get(s, u256(0)) + u256(1)
        self.xp[r] = self.xp.get(r, u256(0)) + u256(1)

    # =========================
    # 10. CANCELLATION / EXPIRY
    # =========================

    @gl.public.write
    def cancel_inactive(self, deal_id_int: int) -> None:
        deal_id = u256(deal_id_int)
        self._only_sender(deal_id)
        self._not_blacklisted(gl.message.sender_address)
        self._respect_delay(gl.message.sender_address)

        state = self.deal_state.get(deal_id, u256(99))
        if state != self._STATE_INACTIVE():
            raise UserError("Deal not inactive")

        deposit = self.deal_deposit.get(deal_id, u256(0))
        if deposit > u256(0):
            self.deal_deposit[deal_id] = u256(0)
            self._send_native(self.deal_sender[deal_id], deposit)

        self.deal_state[deal_id] = self._STATE_CANCELLED()
        self.deal_finalized_at[deal_id] = self._now()

    @gl.public.write
    def expire_deal(self, deal_id_int: int) -> None:
        deal_id = u256(deal_id_int)
        self._only_participant(deal_id)
        self._not_blacklisted(gl.message.sender_address)
        self._respect_delay(gl.message.sender_address)

        state = self.deal_state.get(deal_id, u256(99))
        now = self._now()

        if state == self._STATE_INACTIVE():
            deadline = self.deal_activation_deadline.get(deal_id, u256(0))
            if deadline == u256(0) or now <= deadline:
                raise UserError("Activation deadline not passed")
        elif state == self._STATE_ACTIVE():
            deadline = self.deal_finalization_deadline.get(deal_id, u256(0))
            if deadline == u256(0) or now <= deadline:
                raise UserError("Finalization deadline not passed")
        else:
            raise UserError("Not expirable state")

        deposit = self.deal_deposit.get(deal_id, u256(0))
        if deposit > u256(0):
            self.deal_deposit[deal_id] = u256(0)
            self._send_native(self.deal_sender[deal_id], deposit)

        self.deal_state[deal_id] = self._STATE_CANCELLED()
        self.deal_finalized_at[deal_id] = now

    # =========================
    # 11. FINALIZATION: NFT / STABLE
    # =========================

    @gl.public.write
    def finalize_to_nft(self, deal_id_int: int, metadata: str) -> None:
        deal_id = u256(deal_id_int)
        self._only_recipient(deal_id)
        self._not_blacklisted(gl.message.sender_address)
        self._respect_delay(gl.message.sender_address)

        state = self.deal_state.get(deal_id, u256(99))
        if state != self._STATE_ACTIVE():
            raise UserError("Deal not active")

        deadline = self.deal_finalization_deadline.get(deal_id, u256(0))
        if deadline != u256(0) and self._now() > deadline:
            raise UserError("Finalization deadline passed")

        self.deal_state[deal_id] = self._STATE_FINAL_NFT()
        self.deal_nft_metadata[deal_id] = metadata
        self.deal_finalized_at[deal_id] = self._now()

        r = self.deal_recipient[deal_id]
        self.xp[r] = self.xp.get(r, u256(0)) + u256(5)
        self.wins[r] = self.wins.get(r, u256(0)) + u256(1)

    @gl.public.write
    def finalize_to_stable(self, deal_id_int: int) -> int:
        deal_id = u256(deal_id_int)
        self._only_recipient(deal_id)
        self._not_blacklisted(gl.message.sender_address)
        self._respect_delay(gl.message.sender_address)

        state = self.deal_state.get(deal_id, u256(99))
        if state != self._STATE_ACTIVE():
            raise UserError("Deal not active")

        deadline = self.deal_finalization_deadline.get(deal_id, u256(0))
        if deadline != u256(0) and self._now() > deadline:
            raise UserError("Finalization deadline passed")

        deposit = self.deal_deposit.get(deal_id, u256(0))
        if deposit == u256(0):
            raise UserError("No deposit")

        fee = (deposit * self.transform_fee_bps) // u256(10_000)
        if fee > deposit:
            fee = deposit

        net = deposit - fee
        if net == u256(0):
            raise UserError("Net amount is zero")

        recipient = self.deal_recipient[deal_id]

        self.deal_state[deal_id] = self._STATE_FINAL_STABLE()
        self.deal_finalized_at[deal_id] = self._now()
        self.deal_current_value[deal_id]
