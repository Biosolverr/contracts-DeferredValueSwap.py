# v0.3.1
# { "Depends": "py-genlayer:latest" }

from genlayer import *
import time
import typing
import json


class DeferredValueSwap(gl.Contract):
    """AI-Powered Escrow on GenLayer (tutorial-complete)"""

    # =========================
    # 1) STATES
    # =========================

    def _STATE_INACTIVE(self) -> u256:
        return u256(0)

    def _STATE_ACTIVE(self) -> u256:
        return u256(1)

    def _STATE_FINAL_NFT(self) -> u256:
        return u256(2)

    def _STATE_FINAL_STABLE(self) -> u256:
        return u256(3)

    def _STATE_CANCELLED(self) -> u256:
        return u256(4)

    def _STATE_DISPUTED(self) -> u256:
        return u256(5)

    # =========================
    # 2) STORAGE
    # =========================

    next_deal_id: u256

    deal_sender: TreeMap[u256, Address]
    deal_recipient: TreeMap[u256, Address]
    deal_state: TreeMap[u256, u256]

    deal_initial_value: TreeMap[u256, u256]
    deal_current_value: TreeMap[u256, u256]
    deal_deposit: TreeMap[u256, u256]

    deal_created_at: TreeMap[u256, u256]
    deal_activated_at: TreeMap[u256, u256]
    deal_finalized_at: TreeMap[u256, u256]

    deal_activation_deadline: TreeMap[u256, u256]
    deal_finalization_deadline: TreeMap[u256, u256]

    deal_offchain_ref: TreeMap[u256, str]
    deal_nft_metadata: TreeMap[u256, str]

    # Disputes
    deal_dispute_open: TreeMap[u256, u256]
    deal_claim_by: TreeMap[u256, Address]
    deal_claim_reason: TreeMap[u256, str]
    deal_claim_opened_at: TreeMap[u256, u256]
    deal_claim_deadline: TreeMap[u256, u256]

    deal_challenge_by: TreeMap[u256, Address]
    deal_challenge_reason: TreeMap[u256, str]

    deal_resolution_mode: TreeMap[u256, u256]  # 0=none,1=owner_manual,2=ai_judge
    deal_resolution_note: TreeMap[u256, str]

    dispute_period_sec: u256

    # Economics
    base_activation_fee: u256
    global_value_multiplier_bps: u256
    transform_fee_bps: u256
    protocol_fees_collected: u256

    # Security
    blacklisted: TreeMap[Address, u256]
    max_deal_value: u256
    min_delay_sec: u256
    last_action_at: TreeMap[Address, u256]

    default_activation_period_sec: u256
    default_finalization_period_sec: u256

    # Reputation
    xp: TreeMap[Address, u256]
    wins: TreeMap[Address, u256]

    # Admin
    owner: Address

    # =========================
    # HELPERS
    # =========================

    def _now(self) -> u256:
        return u256(int(time.time()))

    def _only_owner(self) -> None:
        if gl.message.sender_address != self.owner:
            raise UserError("Only owner")

    def _not_blacklisted(self, addr: Address) -> None:
        if self.blacklisted.get(addr, u256(0)) == u256(1):
            raise UserError("Blacklisted")

    def _respect_delay(self, addr: Address) -> None:
        if self.min_delay_sec == u256(0):
            return
        last = self.last_action_at.get(addr, u256(0))
        now = self._now()
        if last != u256(0) and now < last + self.min_delay_sec:
            raise UserError("Action too frequent")
        self.last_action_at[addr] = now

    def _only_sender(self, deal_id: u256) -> None:
        sender = self.deal_sender.get(deal_id)
        if sender is None:
            raise UserError("Unknown deal")
        if sender != gl.message.sender_address:
            raise UserError("Only sender")

    def _only_recipient(self, deal_id: u256) -> None:
        recipient = self.deal_recipient.get(deal_id)
        if recipient is None:
            raise UserError("Unknown deal")
        if recipient != gl.message.sender_address:
            raise UserError("Only recipient")

    def _only_participant(self, deal_id: u256) -> None:
        me = gl.message.sender_address
        sender = self.deal_sender.get(deal_id)
        recipient = self.deal_recipient.get(deal_id)
        if sender is None:
            raise UserError("Unknown deal")
        if me != sender and me != recipient:
            raise UserError("Only sender or recipient")

    def _calc_value(self, initial: u256) -> u256:
        if self.global_value_multiplier_bps == u256(0):
            return initial
        return (initial * self.global_value_multiplier_bps) // u256(10_000)

    # NOTE: this is the same transfer helper as in the tutorial text.
    # If payouts fail in your environment, the issue is usually the runtime transfer primitive.
    def _send_native(self, to: Address, amount: u256) -> None:
        if amount == u256(0):
            return
        if self.balance < amount:
            raise UserError("Contract balance insufficient")
        proxy = gl.get_contract_at(to)
        proxy.emit_transfer(value=amount)

    def _parse_json(self, raw: str) -> typing.Any:
        cleaned = raw.replace("```json", "").replace("```", "").strip()
        return json.loads(cleaned)

    # =========================
    # CONSTRUCTOR
    # =========================

    def __init__(self):
        self.next_deal_id = u256(1)
        self.owner = gl.message.sender_address

        self.base_activation_fee = u256(0)
        self.global_value_multiplier_bps = u256(10_000)  # 1.0x
        self.transform_fee_bps = u256(100)               # 1%

        self.protocol_fees_collected = u256(0)

        self.max_deal_value = u256(0)
        self.min_delay_sec = u256(0)

        # Tutorial default is often 0; you can tune these later via set_timeouts().
        self.default_activation_period_sec = u256(0)
        self.default_finalization_period_sec = u256(0)

        self.dispute_period_sec = u256(0)

    # =========================
    # DEAL FLOW
    # =========================

    @gl.public.write.payable
    def create_deal(self, recipient_hex: str, value: int, offchain_ref: str) -> int:
        sender = gl.message.sender_address
        self._not_blacklisted(sender)
        self._respect_delay(sender)

        if value <= 0:
            raise UserError("Value must be > 0")

        v = u256(value)
        if self.max_deal_value != u256(0) and v > self.max_deal_value:
            raise UserError("Value exceeds max_deal_value")

        recipient = Address(recipient_hex)
        self._not_blacklisted(recipient)

        sent = gl.message.value
        fee = self.base_activation_fee
        expected = v + fee
        if sent != expected:
            raise UserError("Sent value must equal value + base_activation_fee")

        if fee > u256(0):
            self.protocol_fees_collected += fee

        deal_id = self.next_deal_id
        self.next_deal_id = deal_id + u256(1)
        now = self._now()

        self.deal_sender[deal_id] = sender
        self.deal_recipient[deal_id] = recipient
        self.deal_state[deal_id] = self._STATE_INACTIVE()

        self.deal_initial_value[deal_id] = v
        self.deal_current_value[deal_id] = self._calc_value(v)
        self.deal_deposit[deal_id] = v

        self.deal_created_at[deal_id] = now
        self.deal_offchain_ref[deal_id] = offchain_ref

        if self.default_activation_period_sec > u256(0):
            self.deal_activation_deadline[deal_id] = now + self.default_activation_period_sec
        else:
            self.deal_activation_deadline[deal_id] = u256(0)

        self.deal_finalization_deadline[deal_id] = u256(0)

        self.xp[sender] = self.xp.get(sender, u256(0)) + u256(1)
        return int(deal_id)

    @gl.public.write
    def activate_deal(self, deal_id_int: int) -> None:
        deal_id = u256(deal_id_int)
        self._only_participant(deal_id)
        self._not_blacklisted(gl.message.sender_address)
        self._respect_delay(gl.message.sender_address)

        state = self.deal_state.get(deal_id, u256(99))
        if state != self._STATE_INACTIVE():
            raise UserError("Deal not inactive")

        deadline = self.deal_activation_deadline.get(deal_id, u256(0))
        if deadline != u256(0) and self._now() > deadline:
            raise UserError("Activation deadline passed")

        self.deal_state[deal_id] = self._STATE_ACTIVE()
        now = self._now()
        self.deal_activated_at[deal_id] = now

        if self.default_finalization_period_sec > u256(0):
            self.deal_finalization_deadline[deal_id] = now + self.default_finalization_period_sec

        s = self.deal_sender[deal_id]
        r = self.deal_recipient[deal_id]
        self.xp[s] = self.xp.get(s, u256(0)) + u256(1)
        self.xp[r] = self.xp.get(r, u256(0)) + u256(1)

    # =========================
    # CANCELLATION / EXPIRY
    # =========================

    @gl.public.write
    def cancel_inactive(self, deal_id_int: int) -> None:
        deal_id = u256(deal_id_int)
        self._only_sender(deal_id)
        self._not_blacklisted(gl.message.sender_address)
        self._respect_delay(gl.message.sender_address)

        state = self.deal_state.get(deal_id, u256(99))
        if state != self._STATE_INACTIVE():
            raise UserError("Deal not inactive")

        deposit = self.deal_deposit.get(deal_id, u256(0))
        if deposit > u256(0):
            self.deal_deposit[deal_id] = u256(0)
            self._send_native(self.deal_sender[deal_id], deposit)

        self.deal_state[deal_id] = self._STATE_CANCELLED()
        self.deal_finalized_at[deal_id] = self._now()

    @gl.public.write
    def expire_deal(self, deal_id_int: int) -> None:
        deal_id = u256(deal_id_int)
        self._only_participant(deal_id)
        self._not_blacklisted(gl.message.sender_address)
        self._respect_delay(gl.message.sender_address)

        state = self.deal_state.get(deal_id, u256(99))
        now = self._now()

        if state == self._STATE_INACTIVE():
            deadline = self.deal_activation_deadline.get(deal_id, u256(0))
            if deadline == u256(0) or now <= deadline:
                raise UserError("Activation deadline not passed")
        elif state == self._STATE_ACTIVE():
            deadline = self.deal_finalization_deadline.get(deal_id, u256(0))
            if deadline == u256(0) or now <= deadline:
                raise UserError("Finalization deadline not passed")
        else:
            raise UserError("Not expirable state")

        deposit = self.deal_deposit.get(deal_id, u256(0))
        if deposit > u256(0):
            self.deal_deposit[deal_id] = u256(0)
            self._send_native(self.deal_sender[deal_id], deposit)

        self.deal_state[deal_id] = self._STATE_CANCELLED()
        self.deal_finalized_at[deal_id] = now

    # =========================
    # FINALIZATION
    # =========================

    @gl.public.write
    def finalize_to_nft(self, deal_id_int: int, metadata: str) -> None:
        deal_id = u256(deal_id_int)
        self._only_recipient(deal_id)
        self._not_blacklisted(gl.message.sender_address)
        self._respect_delay(gl.message.sender_address)

        state = self.deal_state.get(deal_id, u256(99))
        if state != self._STATE_ACTIVE():
            raise UserError("Deal not active")

        deadline = self.deal_finalization_deadline.get(deal_id, u256(0))
        if deadline != u256(0) and self._now() > deadline:
            raise UserError("Finalization deadline passed")

        self.deal_state[deal_id] = self._STATE_FINAL_NFT()
        self.deal_nft_metadata[deal_id] = metadata
        self.deal_finalized_at[deal_id] = self._now()

        r = self.deal_recipient[deal_id]
        self.xp[r] = self.xp.get(r, u256(0)) + u256(5)
        self.wins[r] = self.wins.get(r, u256(0)) + u256(1)

    @gl.public.write
    def finalize_to_stable(self, deal_id_int: int) -> int:
        deal_id = u256(deal_id_int)
        self._only_recipient(deal_id)
        self._not_blacklisted(gl.message.sender_address)
        self._respect_delay(gl.message.sender_address)

        state = self.deal_state.get(deal_id, u256(99))
        if state != self._STATE_ACTIVE():
            raise UserError("Deal not active")

        deadline = self.deal_finalization_deadline.get(deal_id, u256(0))
        if deadline != u256(0) and self._now() > deadline:
            raise UserError("Finalization deadline passed")

        deposit = self.deal_deposit.get(deal_id, u256(0))
        if deposit ==
